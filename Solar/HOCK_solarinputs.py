# -*- coding: utf-8 -*-
"""
Created on Fri Jun 16 15:25:49 2023

1. Convert DEM's to aspect, slope grids
2. Save DEM, aspect, and slope as txt files in the correct format for HOCK model
3. scp files to cedar and run solar model
4. scp solar outputs back here
5. Plot solar results! compare different years

@author: katierobinson
"""

import numpy as np
import matplotlib.pyplot as plt
from osgeo import gdal
import sys
import os
import pandas as pd
from PIL import Image
sys.path.insert(1,'F:\Mass Balance Model\Kaskawulsh-Mass-Balance\RunModel')
from Model_functions_ver4 import model_domain

# Where to save the DEM/slope/aspect inputs generated by this script:
path_to_files = 'F:/Mass Balance Model/Kaskawulsh-Mass-Balance/Solar/Hock_model_inputs'

Zgrid, Xgrid, Ygrid, xbounds, ybounds, Sfc = model_domain(catchment=True)

def get_array_from_tif(file):
    image = Image.open(file)
    array = np.array(image)
    array[np.where(array == -9999)] = np.nan
    
    return array

DEM2018_resampled = get_array_from_tif('F:/Mass Balance Model/Kaskawulsh-Mass-Balance/SurfaceZ/Coregistered_DEMs/gdal/2018DEM_coregistered_regridded_average.tif')
# Replace nans with the nearest neighbour val:
def gapfill(gappy_raster):
    gapfree_raster = np.array(gappy_raster)     # make a copy of the original raster
    
    # For each nan in the raster:
    for i in range (0,len(np.where(np.isnan(gappy_raster))[0])):
        Xgrid_copy = np.array(Xgrid)
        Ygrid_copy = np.array(Ygrid)
        row = np.where(np.isnan(gappy_raster))[0][i]
        col = np.where(np.isnan(gappy_raster))[1][i]
    
        # Get the coordinates of the nan cell
        x = Xgrid[row,col]
        y = Ygrid[row,col]
        
        # set the corresponding cell in Xgrid/Ygrid copy arrays to NaN
        Xgrid_copy[row,col] = np.nan
        Ygrid_copy[row,col] = np.nan
        
        # Find the distance of every surrounding cell to the NaN cell
        x_dist = Xgrid_copy - x
        y_dist = Ygrid_copy - y
        distance = np.sqrt((x_dist**2)+(y_dist**2))
       
        # Get the 4 closest cells (up, down, left, right)
        closest_cells = np.where(distance == np.nanmin(distance)) # should be 4 each time

        # If the closest cells are all NaNs, set find the NEXT closest cells that are non-NaN
        while np.isnan(np.nanmean(gappy_raster[closest_cells])):
            distance[closest_cells] = np.nan
            closest_cells = np.where(distance == np.nanmin(distance))

        # Get the mean elevation of the surrounding cells, and replace the gap in the original raster.    
        new_elev = np.nanmean(gappy_raster[closest_cells])
        gapfree_raster[row,col] = new_elev
        print('NaN replaced with new elev:' + str(new_elev))
    
    return gapfree_raster
  
print('Gap-filling the 2018 DEM')    
DEM2018_gapfilled = gapfill(DEM2018_resampled)
print('number of NaN cells in new raster:',str(np.where(np.isnan(DEM2018_gapfilled))[0]))

# Following functions adapted from: https://here.isnew.info/how-to-save-a-numpy-array-as-a-geotiff-file-using-gdal.html 
# Define a function that reads in a geotiff, and returns an array + a gdal datset containing the geospatial information
def read_geotiff(filename):
    ds = gdal.Open(filename)
    band = ds.GetRasterBand(1)
    arr = band.ReadAsArray()
    return arr, ds

# Define a function to write a geotiff, using an array and an input dataset containing geospatial information
def write_geotiff(filename, arr, in_ds):
    if arr.dtype == np.float32:
        arr_type = gdal.GDT_Float32
    else:
        arr_type = gdal.GDT_Int32

    driver = gdal.GetDriverByName("GTiff")
    out_ds = driver.Create(filename, arr.shape[1], arr.shape[0], 1, arr_type)
    # Get geospatial information from input dataset
    out_ds.SetProjection(in_ds.GetProjection()) 
    out_ds.SetGeoTransform(in_ds.GetGeoTransform())
    band = out_ds.GetRasterBand(1)
    # Write the input array to file
    band.WriteArray(arr)
    band.FlushCache()
    band.ComputeStatistics(False)
    
EtienneBerthier_DEM, DEM_georeference = read_geotiff('F:/Mass Balance Model/Kaskawulsh-Mass-Balance/SurfaceZ/Coregistered_DEMs/gdal/2018DEM_coregistered_regridded_average.tif')
# Convert the 2018 gapfilled DEM to tif using the geospatial info from the original E.B. DEM
write_geotiff('DEM2018_georef.tif', DEM2018_gapfilled, DEM_georeference)

###############################################################################
# STEP 1: GENERATE DEMs (tif format) FOR EACH YEAR 1979-2022
###############################################################################
print('Loading smoothed dh/dt map for 1979-2022')
dhdt = np.load('F:/Mass Balance Model/Kaskawulsh-Mass-Balance/SurfaceZ/1977-2018_smoothed_dhdt.npy')

# Fill area outside KW catchment with 0 change - since off glacier terrain should be stable.
dhdt[np.where(np.isnan(dhdt))] = 0

# Plot dhdt map
plt.figure(figsize=(10,5))
plt.contourf(Xgrid,Ygrid,dhdt,cmap = 'RdYlBu',levels=np.linspace(-2,2,21))
legend = plt.colorbar()
plt.axis('equal') 
legend.ax.set_ylabel('Elevation change (m a$^{-1}$)', rotation=270,fontsize=14,labelpad=20)
plt.tight_layout()

# For each year, generate an array of the surfae elevation and save as a tif file.
print('Generate DEMs for 1979--2022')
for year in np.arange(2022,1978,-1):
    print(year)
    
    # Get DEM array for each year (constant after 2018)
    if year >= 2018:
        dem = np.array(DEM2018_gapfilled)
    else:
        dem = np.array(DEM2018_gapfilled) - ((2018-year)*(dhdt))
        
    # Convert DEM array to georeferenced tif:
    fname = 'KW_DEM_' + str(year) + '.tif'
    DEMpath = os.path.join(path_to_files,fname)
    write_geotiff(DEMpath,dem,DEM_georeference)
        
    # Open geotiff DEM with GDAL
    dem_dataset = gdal.Open(DEMpath)
    
    # Calculate Aspect:
    asp = gdal.DEMProcessing(os.path.join(path_to_files,'KW_Aspect_' + str(year) + '.tif'), dem_dataset, "aspect",  computeEdges=True) 
    aspect_array = asp.GetRasterBand(1).ReadAsArray()

    # Calculate Slope:
    slp = gdal.DEMProcessing(os.path.join(path_to_files,'KW_Slope_' + str(year) + '.tif'), dem_dataset, "slope",  computeEdges=True)
    slope_array = slp.GetRasterBand(1).ReadAsArray()
    
    # Calculate Hillshade:
    hill = gdal.DEMProcessing(os.path.join(path_to_files,'KW_Hillshade_' + str(year) + '.tif'), dem_dataset, "hillshade",  computeEdges=True)
    hillshade_array = hill.GetRasterBand(1).ReadAsArray()
    
    # Close datsets
    slp = asp = hill = dem_dataset = None
    
    # Convert slope/aspect/dem to a text file (formatted for input to Hock solar model)
    # ncols, nrows, nodata must be integers
    data = [['ncols',int(dem.shape[1])],['nrows',int(dem.shape[0])],['xllcorner',Xgrid[-1,0]],['yllcorner',Ygrid[-1,0]],['cellsize',200],['nodata_value',-9999]]
    df = pd.DataFrame(data,columns=['name','number'])

    with open(os.path.join(path_to_files,'KW_DEM_' + str(year) + '.txt'),'a') as f:
        f.seek(0)
        np.savetxt(f,data,fmt='%s') # adds the array to the bottom of the textfile
        np.savetxt(f,dem,fmt='%1.0f') # adds the array to the bottom of the textfile
        f.close()
    with open(os.path.join(path_to_files,'KW_Slope_' + str(year) + '.txt'),'a') as f:
        f.seek(0)
        np.savetxt(f,data,fmt='%s') # adds the array to the bottom of the textfile
        np.savetxt(f,slope_array,fmt='%1.0f') # adds the array to the bottom of the textfile
        f.close()
    with open(os.path.join(path_to_files,'KW_Aspect_' + str(year) + '.txt'),'a') as f:
        f.seek(0)
        np.savetxt(f,data,fmt='%s') # adds the array to the bottom of the textfile
        np.savetxt(f,aspect_array,fmt='%1.0f') # adds the array to the bottom of the textfile
        f.close()

    
# =============================================================================
#     plt.figure(figsize=(16,5))
#     plt.subplot(1,2,1)
#     plt.contourf(Xgrid,np.flipud(Ygrid),aspect_array,levels=np.linspace(0,360,37),cmap='twilight')
#     legend = plt.colorbar()
#     legend.ax.set_ylabel('Aspect ($\circ$)', rotation=270,fontsize=14,labelpad=20)
#     plt.axis('equal') 
#     plt.title('Aspect (' + str(year) + ')',fontsize=14)
#     plt.xlabel('Easting',fontsize=14)
#     plt.ylabel('Northing',fontsize=14)
#     
#     plt.subplot(1,2,2)
#     plt.contourf(Xgrid,Ygrid,slope_array,levels=np.linspace(0,60,21),cmap='YlGnBu')
#     legend = plt.colorbar()
#     legend.ax.set_ylabel('Slope ($\circ$)', rotation=270,fontsize=14,labelpad=20)
#     plt.axis('equal') 
#     plt.title('Slope (' + str(year) + ')',fontsize=14)
#     plt.xlabel('Easting',fontsize=14)
#     plt.ylabel('Northing',fontsize=14)
# 
#     plt.tight_layout()
#     plt.close()
# =============================================================================

